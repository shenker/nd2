{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quickstart","text":"<p>.nd2 (Nikon NIS Elements) file reader.</p> <p>Features complete metadata retrieval, and many array outputs, including <code>to_dask()</code> and <code>to_xarray()</code> options for lazy and/or annotated arrays (in addition to numpy arrays).</p> <p>This library is thoroughly tested against many nd2 files with the goal of maximizing compatibility and data extraction. (If you find an nd2 file that fails in any way, please open an issue with the file!)</p> <p>Note</p> <p>This library is not affiliated with Nikon in any way, but we are grateful for assistance from the SDK developers at Laboratory Imaging.</p>"},{"location":"#installation","title":"Installation","text":"<p>From pip:</p> <pre><code>pip install nd2\n</code></pre> <p>From conda:</p> <pre><code>conda install -c conda-forge nd2\n</code></pre>"},{"location":"#with-legacy-nd2-file-support","title":"With legacy nd2 file support","text":"<p>Legacy nd2 (JPEG2000) files are also supported, but require <code>imagecodecs</code>.  To install with support for these files use the <code>legacy</code> extra:</p> <pre><code>pip install nd2[legacy]\n</code></pre>"},{"location":"#faster-xml-parsing","title":"Faster XML parsing","text":"<p>Much of the metadata in the file stored as XML.  If found in the environment, <code>nd2</code> will use <code>lxml</code> which is faster than the built-in <code>xml</code> module.  To install with support for <code>lxml</code> use:</p> <pre><code>pip install nd2 lxml\n</code></pre>"},{"location":"#usage-overview","title":"Usage overview","text":"<p>For complete usage details, see the API</p>"},{"location":"#reading-nd2-files-into-arrays","title":"Reading nd2 files into arrays","text":"<p>To quickly read an nd2 file into a numpy, dask, or xarray array, use <code>nd2.imread()</code>:</p> <pre><code>import nd2\n\n# read to numpy array\nmy_array = nd2.imread('some_file.nd2')\n\n# read to dask array\nmy_array = nd2.imread('some_file.nd2', dask=True)\n\n# read to xarray\nmy_array = nd2.imread('some_file.nd2', xarray=True)\n\n# read file to dask-xarray\nmy_array = nd2.imread('some_file.nd2', xarray=True, dask=True)\n</code></pre>"},{"location":"#extracting-metadata","title":"Extracting metadata","text":"<p>If you want to get metadata, then use the <code>nd2.ND2File</code> class directly:</p> <pre><code>myfile = nd2.ND2File('some_file.nd2')\n</code></pre> <p>Tip</p> <p>It's best to use it as a context manager, so that the file is closed automatically when you're done with it.</p> <pre><code>with nd2.ND2File('some_file.nd2') as myfile:\n    print(myfile.metadata)\n    ...\n</code></pre> <p>The primary metadata is available as attributes on the file object:</p> <p>The key metadata outputs are:</p> <ul> <li><code>ND2File.attributes</code></li> <li><code>ND2File.metadata</code> / <code>ND2File.frame_metadata()</code></li> <li><code>ND2File.experiment</code></li> <li><code>ND2File.text_info</code></li> <li><code>ND2File.events()</code></li> </ul> <p>Other attributes of note include:</p> ATTRIBUTE EXAMPLE OUTPUT <code>myfile.shape</code> <code>(10, 2, 256, 256)</code> <code>myfile.ndim</code> <code>4</code> <code>myfile.dtype</code> <code>np.dtype('uint16')</code> <code>myfile.size</code> <code>1310720</code> (total voxel elements) <code>myfile.sizes</code> <code>{'T': 10, 'C': 2, 'Y': 256, 'X': 256}</code> <code>myfile.voxel_size()</code> <code>VoxelSize(x=0.65, y=0.65, z=1.0)</code> <code>myfile.is_rgb</code> <code>False</code> (whether the file is rgb)"},{"location":"#binary-masks-and-rois","title":"Binary masks and ROIs","text":"<p>Binary masks, if present, can be accessed at <code>ND2File.binary_data</code>.</p> <p>ROIs, if present, can be accessed at <code>ND2File.rois</code>.</p>"},{"location":"#theres-more-in-there","title":"There's more in there!","text":"<p>If you're still looking for something that you don't see in the above properties and methods, try looking through:</p> <ul> <li>ND2File.custom_data</li> <li>ND2File.unstructured_metadata()</li> </ul> <p>These methods parse and return more of the metadata found in the file, but no attempt is made to extract it into a more useful form.</p>"},{"location":"API/nd2/","title":"nd2","text":"<p>nd2: A Python library for reading and writing ND2 files.</p>"},{"location":"API/nd2/#nd2.ND2File","title":"<code>ND2File</code>","text":"<p>Main objecting for opening and extracting data from an nd2 file.</p> <pre><code>with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n    ...\n</code></pre> <p>The key metadata outputs are:</p> <ul> <li>attributes</li> <li>metadata / frame_metadata</li> <li>experiment</li> <li>text_info</li> </ul> <p>Some files may also have:</p> <ul> <li>binary_data</li> <li>rois</li> </ul> <p>Tip</p> <p>For a simple way to read nd2 file data into an array, see nd2.imread.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>Path | str</code>)         \u2013          <p>Filename of an nd2 file.</p> </li> <li> <code>validate_frames</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to verify (and attempt to fix) frames whose positions have been shifted relative to the predicted offset (i.e. in a corrupted file). This comes at a slight performance penalty at file open, but may \"rescue\" some corrupt files. by default False.</p> </li> <li> <code>search_window</code>             (<code>int</code>, default:                 <code>100</code> )         \u2013          <p>When validate_frames is true, this is the search window (in KB) that will be used to try to find the actual chunk position. by default 100 KB</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.attributes","title":"<code>attributes: Attributes</code>  <code>cached</code> <code>property</code>","text":"<p>Core image attributes.</p> <p>Example Output</p> <pre><code>Attributes(\n    bitsPerComponentInMemory=16,\n    bitsPerComponentSignificant=16,\n    componentCount=2,\n    heightPx=32,\n    pixelDataType='unsigned',\n    sequenceCount=60,\n    widthBytes=128,\n    widthPx=32,\n    compressionLevel=None,\n    compressionType=None,\n    tileHeightPx=None,\n    tileWidthPx=None,\n    channelCount=2\n)\n</code></pre> <p>Returns:</p> <ul> <li> <code>attrs</code> (            <code>Attributes</code> )        \u2013          <p>Core image attributes</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.binary_data","title":"<code>binary_data: BinaryLayers | None</code>  <code>cached</code> <code>property</code>","text":"<p>Return binary layers embedded in the file.</p> <p>The returned <code>BinaryLayers</code> object is an immutable sequence of <code>BinaryLayer</code> objects, one for each binary layer in the file (there will usually be a binary layer associated with each channel in the dataset).</p> <p>Each <code>BinaryLayer</code> object in the sequence has a <code>name</code> attribute, and a <code>data</code> attribute which is list of numpy arrays (or <code>None</code> if there was no binary mask for that frame).  The length of the list will be the same as the number of sequence frames in this file (i.e. <code>self.attributes.sequenceCount</code>). <code>BinaryLayers</code> can be indexed directly with an integer corresponding to the frame index.</p> <p>Both the <code>BinaryLayers</code> and individual <code>BinaryLayer</code> objects can be cast to a numpy array with <code>np.asarray()</code>, or by using the <code>.asarray()</code> method</p> <p>Returns:</p> <ul> <li> <code>BinaryLayers | None</code>         \u2013          <p>The binary layers embedded in the file, or None if there are no binary layers.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = ND2File(\"path/to/file.nd2\")\n&gt;&gt;&gt; f.binary_data\n&lt;BinaryLayers with 4 layers&gt;\n&gt;&gt;&gt; first_layer = f.binary_data[0]  # the first binary layer\n&gt;&gt;&gt; first_layer\nBinaryLayer(name='attached Widefield green (green color)',\ncomp_name='Widefield Green', comp_order=2, color=65280, color_mode=0,\nstate=524288, file_tag='RleZipBinarySequence_1_v1', layer_id=2)\n&gt;&gt;&gt; first_layer.data  # list of arrays\n# you can also index in to the BinaryLayers object itself\n&gt;&gt;&gt; first_layer[0]  # get binary data for first frame (or None if missing)\n&gt;&gt;&gt; np.asarray(first_layer)  # cast to array matching shape of full sequence\n&gt;&gt;&gt; np.asarray(f.binary_data).shape  # cast all layers to array\n(4, 3, 4, 5, 32, 32)\n</code></pre>"},{"location":"API/nd2/#nd2.ND2File.closed","title":"<code>closed: bool</code>  <code>property</code>","text":"<p>Return <code>True</code> if the file is closed.</p>"},{"location":"API/nd2/#nd2.ND2File.components_per_channel","title":"<code>components_per_channel: int</code>  <code>property</code>","text":"<p>Number of components per channel (e.g. 3 for rgb).</p>"},{"location":"API/nd2/#nd2.ND2File.custom_data","title":"<code>custom_data: dict[str, Any]</code>  <code>cached</code> <code>property</code>","text":"<p>Dict of various unstructured custom metadata.</p>"},{"location":"API/nd2/#nd2.ND2File.dtype","title":"<code>dtype: np.dtype</code>  <code>cached</code> <code>property</code>","text":"<p>Image data type.</p>"},{"location":"API/nd2/#nd2.ND2File.experiment","title":"<code>experiment: list[ExpLoop]</code>  <code>cached</code> <code>property</code>","text":"<p>Loop information for each axis of an nD acquisition.</p> Example Output <pre><code>[\n    TimeLoop(\n        count=3,\n        nestingLevel=0,\n        parameters=TimeLoopParams(\n            startMs=0.0,\n            periodMs=1.0,\n            durationMs=0.0,\n            periodDiff=PeriodDiff(\n                avg=3674.199951171875,\n                max=3701.219970703125,\n                min=3647.179931640625\n            )\n        ),\n        type='TimeLoop'\n    ),\n    ZStackLoop(\n        count=5,\n        nestingLevel=1,\n        parameters=ZStackLoopParams(\n            homeIndex=2,\n            stepUm=1.0,\n            bottomToTop=True,\n            deviceName='Ti2 ZDrive'\n        ),\n        type='ZStackLoop'\n    )\n]\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[ExpLoop]</code>         \u2013          </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.is_legacy","title":"<code>is_legacy: bool</code>  <code>property</code>","text":"<p>Whether file is a legacy nd2 (JPEG2000) file.</p>"},{"location":"API/nd2/#nd2.ND2File.is_rgb","title":"<code>is_rgb: bool</code>  <code>property</code>","text":"<p>Whether the image is rgb (i.e. it has 3 or 4 components per channel).</p>"},{"location":"API/nd2/#nd2.ND2File.loop_indices","title":"<code>loop_indices: list[dict[str, int]]</code>  <code>cached</code> <code>property</code>","text":"<p>Return a list of dicts of loop indices for each frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with nd2.ND2File(\"path/to/file.nd2\") as f:\n...     f.loop_indices\n[\n    {'Z': 0, 'T': 0, 'C': 0},\n    {'Z': 0, 'T': 0, 'C': 1},\n    {'Z': 0, 'T': 0, 'C': 2},\n    ...\n]\n</code></pre>"},{"location":"API/nd2/#nd2.ND2File.metadata","title":"<code>metadata: Metadata</code>  <code>cached</code> <code>property</code>","text":"<p>Various metadata (will be <code>dict</code> only if legacy format).</p> Example output <pre><code>Metadata(\n    contents=Contents(channelCount=2, frameCount=15),\n    channels=[\n        Channel(\n            channel=ChannelMeta(\n                name='Widefield Green',\n                index=0,\n                colorRGB=65371,\n                emissionLambdaNm=535.0,\n                excitationLambdaNm=None\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None,\n                TimeLoop=0,\n                XYPosLoop=None,\n                ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName='Plan Fluor 10x Ph1 DLL',\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=['fluorescence']\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[\n                    0.652452890023035,\n                    0.652452890023035,\n                    1.0\n                ],\n                axesInterpretation=['distance', 'distance', 'distance'],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086\n                ],\n                componentCount=1,\n                componentDataType='unsigned',\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None\n            )\n        ),\n        Channel(\n            channel=ChannelMeta(\n                name='Widefield Red',\n                index=1,\n                colorRGB=22015,\n                emissionLambdaNm=620.0,\n                excitationLambdaNm=None\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None,\n                TimeLoop=0,\n                XYPosLoop=None,\n                ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName='Plan Fluor 10x Ph1 DLL',\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=['fluorescence']\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[\n                    0.652452890023035,\n                    0.652452890023035,\n                    1.0\n                ],\n                axesInterpretation=['distance', 'distance', 'distance'],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086\n                ],\n                componentCount=1,\n                componentDataType='unsigned',\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None\n            )\n        )\n    ]\n)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Metadata | dict</code>         \u2013          <p>dict if legacy format, else <code>Metadata</code></p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.nbytes","title":"<code>nbytes: int</code>  <code>property</code>","text":"<p>Total bytes of image data.</p>"},{"location":"API/nd2/#nd2.ND2File.ndim","title":"<code>ndim: int</code>  <code>cached</code> <code>property</code>","text":"<p>Number of dimensions (i.e. <code>len(</code><code>self.shape</code><code>)</code>).</p>"},{"location":"API/nd2/#nd2.ND2File.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>Path of the image.</p>"},{"location":"API/nd2/#nd2.ND2File.rois","title":"<code>rois: dict[int, ROI]</code>  <code>cached</code> <code>property</code>","text":"<p>Return dict of <code>{id: ROI}</code> for all ROIs found in the metadata.</p> <p>Returns:</p> <ul> <li> <code>dict[int, ROI]</code>         \u2013          <p>The dict of ROIs is keyed by the ROI ID.</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.shape","title":"<code>shape: tuple[int, ...]</code>  <code>cached</code> <code>property</code>","text":"<p>Size of each axis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ndfile.shape\n(3, 5, 2, 512, 512)\n</code></pre>"},{"location":"API/nd2/#nd2.ND2File.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>Total number of voxels in the volume (the product of the shape).</p>"},{"location":"API/nd2/#nd2.ND2File.sizes","title":"<code>sizes: dict[str, int]</code>  <code>cached</code> <code>property</code>","text":"<p>Names and sizes for each axis.</p> <p>This is an ordered dict, with the same order as the corresponding shape</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ndfile.sizes\n{'T': 3, 'Z': 5, 'C': 2, 'Y': 512, 'X': 512}\n&gt;&gt;&gt; ndfile.shape\n(3, 5, 2, 512, 512)\n</code></pre>"},{"location":"API/nd2/#nd2.ND2File.text_info","title":"<code>text_info: TextInfo</code>  <code>cached</code> <code>property</code>","text":"<p>Miscellaneous text info.</p> Example Output <pre><code>{\n    'description': 'Metadata:\\r\\nDimensions: T(3) x XY(4) x \u03bb(2) x Z(5)...'\n    'capturing': 'Flash4.0, SN:101412\\r\\nSample 1:\\r\\n  Exposure: 100 ms...'\n    'date': '9/28/2021  9:41:27 AM',\n    'optics': 'Plan Fluor 10x Ph1 DLL'\n}\n</code></pre> <p>Returns:</p> <ul> <li> <code>TextInfo | dict</code>         \u2013          <p>If the file is a legacy nd2 file, a dict is returned. Otherwise, a <code>TextInfo</code> object is returned.</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.version","title":"<code>version: tuple[int, ...]</code>  <code>cached</code> <code>property</code>","text":"<p>Return the file format version as a tuple of ints.</p> <p>Likely values are:</p> <ul> <li><code>(1, 0)</code> = a legacy nd2 file (JPEG2000)</li> <li><code>(2, 0)</code>, <code>(2, 1)</code> = non-JPEG2000 nd2 with xml metadata</li> <li><code>(3, 0)</code> = new format nd2 file with lite variant metadata</li> <li><code>(-1, -1)</code> =</li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>         \u2013          <p>The file format version as a tuple of ints.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>If the file is not a valid nd2 file.</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.asarray","title":"<code>asarray(position: int | None = None) -&gt; np.ndarray</code>","text":"<p>Read image into a numpy.ndarray.</p> <p>For a simple way to read a file into a numpy array, see nd2.imread.</p> <p>Parameters:</p> <ul> <li> <code>position</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>A specific XY position to extract, by default (None) reads all.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>array</code> (            <code>ndarray</code> )        \u2013          </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>if <code>position</code> is a string and is not a valid position name</p> </li> <li> <code>IndexError</code>           \u2013          <p>if <code>position</code> is provided and is out of range</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.close","title":"<code>close() -&gt; None</code>","text":"<p>Close file.</p> <p>Note</p> <p>Files are best opened using a context manager:</p> <pre><code>with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n    ...\n</code></pre> <p>This will automatically close the file when the context exits.</p>"},{"location":"API/nd2/#nd2.ND2File.events","title":"<code>events(*, orient: Literal['records', 'list', 'dict'] = 'records', null_value: Any = float('nan')) -&gt; ListOfDicts | DictOfLists | DictOfDicts</code>","text":"<p>Return tabular data recorded for each frame and/or event of the experiment.</p> <p>This method returns tabular data in the format specified by the <code>orient</code> argument:     - 'records' : list of dict - <code>[{column -&gt; value}, ...]</code> (default)     - 'dict' :    dict of dict - <code>{column -&gt; {index -&gt; value}, ...}</code>     - 'list' :    dict of list - <code>{column -&gt; [value, ...]}</code></p> <p>All return types are passable to pd.DataFrame(). It matches the tabular data reported in the Image Properties &gt; Recorded Data tab of the NIS Viewer.</p> <p>There will be a column for each tag in the <code>CustomDataV2_0</code> section of <code>ND2File.custom_data</code>, as well columns for any events recorded in the data.  Not all cells will be populated, and empty cells will be filled with <code>null_value</code> (default <code>float('nan')</code>).</p> <p>Legacy ND2 files are not supported.</p> <p>Parameters:</p> <ul> <li> <code>orient</code>             (<code>('records', 'dict', 'list')</code>, default:                 <code>'records'</code> )         \u2013          <p>The format of the returned data. See <code>pandas.DataFrame     - 'records' : list of dict -</code>[{column -&gt; value}, ...]<code>(default)     - 'dict' :    dict of dict -</code>{column -&gt; {index -&gt; value}, ...}<code>- 'list' :    dict of list -</code>{column -&gt; [value, ...]}`</p> </li> <li> <code>null_value</code>             (<code>Any</code>, default:                 <code>float('nan')</code> )         \u2013          <p>The value to use for missing data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ListOfDicts | DictOfLists | DictOfDicts</code>         \u2013          <p>Tabular data in the format specified by <code>orient</code>.</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.frame_metadata","title":"<code>frame_metadata(seq_index: int | tuple) -&gt; FrameMetadata | dict</code>","text":"<p>Metadata for specific frame.</p> <p> See also: metadata</p> <p>This includes the global metadata from the metadata function. (will be dict if legacy format).</p> Example output <pre><code>FrameMetadata(\n    contents=Contents(channelCount=2, frameCount=15),\n    channels=[\n        FrameChannel(\n            channel=ChannelMeta(\n                name='Widefield Green',\n                index=0,\n                colorRGB=65371,\n                emissionLambdaNm=535.0,\n                excitationLambdaNm=None\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None,\n                TimeLoop=0,\n                XYPosLoop=None,\n                ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName='Plan Fluor 10x Ph1 DLL',\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=['fluorescence']\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[\n                    0.652452890023035,\n                    0.652452890023035,\n                    1.0\n                ],\n                axesInterpretation=['distance', 'distance', 'distance'],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086\n                ],\n                componentCount=1,\n                componentDataType='unsigned',\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None\n            ),\n            position=Position(\n                stagePositionUm=StagePosition(\n                    x=26950.2,\n                    y=-1801.6000000000001,\n                    z=494.3\n                ),\n                pfsOffset=None,\n                name=None\n            ),\n            time=TimeStamp(\n                absoluteJulianDayNumber=2459486.0682717753,\n                relativeTimeMs=580.3582921028137\n            )\n        ),\n        FrameChannel(\n            channel=ChannelMeta(\n                name='Widefield Red',\n                index=1,\n                colorRGB=22015,\n                emissionLambdaNm=620.0,\n                excitationLambdaNm=None\n            ),\n            loops=LoopIndices(\n                NETimeLoop=None,\n                TimeLoop=0,\n                XYPosLoop=None,\n                ZStackLoop=1\n            ),\n            microscope=Microscope(\n                objectiveMagnification=10.0,\n                objectiveName='Plan Fluor 10x Ph1 DLL',\n                objectiveNumericalAperture=0.3,\n                zoomMagnification=1.0,\n                immersionRefractiveIndex=1.0,\n                projectiveMagnification=None,\n                pinholeDiameterUm=None,\n                modalityFlags=['fluorescence']\n            ),\n            volume=Volume(\n                axesCalibrated=[True, True, True],\n                axesCalibration=[\n                    0.652452890023035,\n                    0.652452890023035,\n                    1.0\n                ],\n                axesInterpretation=['distance', 'distance', 'distance'],\n                bitsPerComponentInMemory=16,\n                bitsPerComponentSignificant=16,\n                cameraTransformationMatrix=[\n                    -0.9998932296054086,\n                    -0.014612644841559427,\n                    0.014612644841559427,\n                    -0.9998932296054086\n                ],\n                componentCount=1,\n                componentDataType='unsigned',\n                voxelCount=[32, 32, 5],\n                componentMaxima=[0.0],\n                componentMinima=[0.0],\n                pixelToStageTransformationMatrix=None\n            ),\n            position=Position(\n                stagePositionUm=StagePosition(\n                    x=26950.2,\n                    y=-1801.6000000000001,\n                    z=494.3\n                ),\n                pfsOffset=None,\n                name=None\n            ),\n            time=TimeStamp(\n                absoluteJulianDayNumber=2459486.0682717753,\n                relativeTimeMs=580.3582921028137\n            )\n        )\n    ]\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>seq_index</code>             (<code>Union[int, tuple]</code>)         \u2013          <p>frame index</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FrameMetadata | dict</code>         \u2013          <p>dict if legacy format, else FrameMetadata</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.is_supported_file","title":"<code>is_supported_file(path: StrOrPath) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Return <code>True</code> if the file is supported by this reader.</p>"},{"location":"API/nd2/#nd2.ND2File.ome_metadata","title":"<code>ome_metadata() -&gt; OME</code>","text":"<p>Return OME metadata for the file.</p>"},{"location":"API/nd2/#nd2.ND2File.open","title":"<code>open() -&gt; None</code>","text":"<p>Open file for reading.</p> <p>Note</p> <p>Files are best opened using a context manager:</p> <pre><code>with nd2.ND2File(\"path/to/file.nd2\") as nd2_file:\n    ...\n</code></pre> <p>This will automatically close the file when the context exits.</p>"},{"location":"API/nd2/#nd2.ND2File.read_frame","title":"<code>read_frame(frame_index: SupportsInt) -&gt; np.ndarray</code>","text":"<p>Read a single frame from the file, indexed by frame number.</p>"},{"location":"API/nd2/#nd2.ND2File.to_dask","title":"<code>to_dask(wrapper: bool = True, copy: bool = True) -&gt; dask.array.core.Array</code>","text":"<p>Create dask array (delayed reader) representing image.</p> <p>This generally works well, but it remains to be seen whether performance is optimized, or if we're duplicating safety mechanisms. You may try various combinations of <code>wrapper</code> and <code>copy</code>, setting both to <code>False</code> will very likely cause segmentation faults in many cases.  But setting one of them to <code>False</code>, may slightly improve read speed in certain cases.</p> <p>Parameters:</p> <ul> <li> <code>wrapper</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>True</code> (the default), the returned object will be a thin subclass of a <code>dask.array.Array</code> (a <code>ResourceBackedDaskArray</code>) that manages the opening and closing of this file when getting chunks via compute(). If <code>wrapper</code> is <code>False</code>, then a pure <code>dask.array.core.Array</code> will be returned. However, when that array is computed, it will incur a file open/close on every chunk that is read (in the <code>_dask_block</code> method).  As such <code>wrapper</code> will generally be much faster, however, it may fail (i.e. result in segmentation faults) with certain dask schedulers.</p> </li> <li> <code>copy</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>True</code> (the default), the dask chunk-reading function will return an array copy. This can avoid segfaults in certain cases, though it may also add overhead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dask_array</code> (            <code>Array</code> )        \u2013          <p>A dask array representing the image data.</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.to_xarray","title":"<code>to_xarray(delayed: bool = True, squeeze: bool = True, position: int | None = None, copy: bool = True) -&gt; xr.DataArray</code>","text":"<p>Return a labeled xarray.DataArray representing image.</p> <p>Xarrays are a powerful way to label and manipulate n-dimensional data with axis-associated coordinates.</p> <p><code>array.dims</code> will be populated according to image metadata, and coordinates will be populated based on pixel spacings. Additional metadata is available in <code>array.attrs['metadata']</code>.</p> <p>Parameters:</p> <ul> <li> <code>delayed</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the DataArray should be backed by dask array or numpy array, by default True (dask).</p> </li> <li> <code>squeeze</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to squeeze singleton dimensions, by default True</p> </li> <li> <code>position</code>             (<code>int</code>, default:                 <code>None</code> )         \u2013          <p>A specific XY position to extract, by default (None) reads all.</p> </li> <li> <code>copy</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Only applies when <code>delayed==True</code>.  See <code>to_dask</code> for details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataArray</code>         \u2013          <p>xarray with all axes labeled.</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.unstructured_metadata","title":"<code>unstructured_metadata(*, strip_prefix: bool = True, include: set[str] | None = None, exclude: set[str] | None = None) -&gt; dict[str, Any]</code>","text":"<p>Exposes, and attempts to decode, each metadata chunk in the file.</p> <p>This is provided as a experimental fallback in the event that <code>ND2File.experiment</code> does not contain all of the information you need. No attempt is made to parse or validate the metadata, and the format of various sections, may change in future versions of nd2. Consumption of this metadata should use appropriate exception handling!</p> <p>The 'ImageMetadataLV' chunk is the most likely to contain useful information, but if you're generally looking for \"hidden\" metadata, it may be helpful to look at the full output.</p> <p>Parameters:</p> <ul> <li> <code>strip_prefix</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to strip the type information from the front of the keys in the dict. For example, if <code>True</code>: <code>uiModeFQ</code> becomes <code>ModeFQ</code> and <code>bUsePFS</code> becomes <code>UsePFS</code>, etc... by default <code>True</code></p> </li> <li> <code>include</code>             (<code>set[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>If provided, only include the specified keys in the output. by default, all metadata sections found in the file are included.</p> </li> <li> <code>exclude</code>             (<code>set[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>If provided, exclude the specified keys from the output. by default <code>None</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dict of the unstructured metadata, with keys that are the type of the metadata chunk (things like 'CustomData|RoiMetadata_v1' or 'ImageMetadataLV'), and values that are associated metadata chunk.</p> </li> </ul>"},{"location":"API/nd2/#nd2.ND2File.voxel_size","title":"<code>voxel_size(channel: int = 0) -&gt; _util.VoxelSize</code>","text":"<p>XYZ voxel size.</p> <p>Parameters:</p> <ul> <li> <code>channel</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Channel for which to retrieve voxel info, by default 0</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VoxelSize</code>         \u2013          <p>Named tuple with attrs <code>x</code>, <code>y</code>, and <code>z</code>.</p> </li> </ul>"},{"location":"API/nd2/#nd2.imread","title":"<code>imread(file: Path | str, *, dask: bool = False, xarray: bool = False, validate_frames: bool = False) -&gt; np.ndarray | xr.DataArray | dask.array.core.Array</code>","text":"<p>Open <code>file</code>, return requested array type, and close <code>file</code>.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Path | str</code>)         \u2013          <p>Filepath (<code>str</code>) or <code>Path</code> object to ND2 file.</p> </li> <li> <code>dask</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, returns a (delayed) <code>dask.array.Array</code>. This will avoid reading any data from disk until specifically requested by using <code>.compute()</code> or casting to a numpy array with <code>np.asarray()</code>. By default <code>False</code>.</p> </li> <li> <code>xarray</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, returns an <code>xarray.DataArray</code>, <code>array.dims</code> will be populated according to image metadata, and coordinates will be populated based on pixel spacings. Additional metadata is available in <code>array.attrs['metadata']</code>. If <code>dask</code> is also <code>True</code>, will return an xarray backed by a delayed dask array. By default <code>False</code>.</p> </li> <li> <code>validate_frames</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to verify (and attempt to fix) frames whose positions have been shifted relative to the predicted offset (i.e. in a corrupted file). This comes at a slight performance penalty at file open, but may \"rescue\" some corrupt files. by default False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[ndarray, Array, DataArray]</code>         \u2013          <p>Array subclass, depending on arguments used.</p> </li> </ul>"},{"location":"API/nd2/#nd2.is_legacy","title":"<code>is_legacy(path: StrOrPath) -&gt; bool</code>","text":"<p>Return <code>True</code> if <code>path</code> is a legacy ND2 file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>Union[str, bytes, PathLike]</code>)         \u2013          <p>A path to query</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether the file is a legacy ND2 file.</p> </li> </ul>"},{"location":"API/nd2/#nd2.is_supported_file","title":"<code>is_supported_file(path: FileOrBinaryIO, open_: Callable[[StrOrPath], BinaryIO] = _open_binary) -&gt; bool</code>","text":"<p>Return <code>True</code> if <code>path</code> can be opened as an nd2 file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>Union[str, bytes, PathLike]</code>)         \u2013          <p>A path to query</p> </li> <li> <code>open_</code>             (<code>Callable[[StrOrBytesPath, str], BinaryIO]</code>, default:                 <code>_open_binary</code> )         \u2013          <p>Filesystem opener, by default <code>builtins.open</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>Whether the can be opened.</p> </li> </ul>"},{"location":"API/nd2/#nd2.rescue_nd2","title":"<code>rescue_nd2(handle: BinaryIO | str, frame_shape: tuple[int, ...] = (), dtype: DTypeLike = 'uint16', max_iters: int | None = None, verbose: bool = True, chunk_start: bytes = _default_chunk_start) -&gt; Iterator[np.ndarray]</code>","text":"<p>Iterator that yields all discovered frames in a file handle.</p> <p>In nd2 files, each \"frame\" contains XY and all channel info (both true channels as well as RGB components).  Frames are laid out as (Y, X, C), and the <code>frame_shape</code> should match the expected frame size.  If <code>frame_shape</code> is not provided, a guess will be made about the vector shape of each frame, but it may be incorrect.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>             (<code>BinaryIO | str</code>)         \u2013          <p>Filepath string, or binary file handle (For example <code>handle = open('some.nd2', 'rb')</code>)</p> </li> <li> <code>frame_shape</code>             (<code>Tuple[int, ...]</code>, default:                 <code>()</code> )         \u2013          <p>expected shape of each frame, by default a 1 dimensional array will be yielded for each frame, which can be reshaped later if desired. NOTE: nd2 frames are generally ordered as (height, width, true_channels, rgbcomponents). So unlike numpy, which would use (channels, Y, X), you should use (Y, X, channels)</p> </li> <li> <code>dtype</code>             (<code>dtype</code>, default:                 <code>'uint16'</code> )         \u2013          <p>Data type, by default np.uint16</p> </li> <li> <code>max_iters</code>             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>A maximum number of frames to yield, by default will yield until the end of the file is reached</p> </li> <li> <code>verbose</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>whether to print info</p> </li> <li> <code>chunk_start</code>             (<code>bytes</code>, default:                 <code>_default_chunk_start</code> )         \u2013          <p>The bytes that start each chunk, by default 0x0ABECEDA.to_bytes(4, \"little\")</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>ndarray</code>         \u2013          <p>each discovered frame in the file</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open('some_bad.nd2', 'rb') as fh:\n&gt;&gt;&gt;     frames = rescue_nd2(fh, (512, 512, 4), 'uint16')\n&gt;&gt;&gt;     ary = np.stack(frames)\n</code></pre> <p>You will likely want to reshape <code>ary</code> after that.</p>"},{"location":"API/nd2_binary/","title":"nd2 (binary masks)","text":"<p>nd2: A Python library for reading and writing ND2 files.</p>"},{"location":"API/nd2_binary/#nd2.BinaryLayers","title":"<code>BinaryLayers</code>","text":"<p>Sequence of Binary Layers found in an ND2 file.</p> <p>This object is a sequence of <code>BinaryLayer</code> objects, one for each binary layer in the file.  Each layer has a <code>name</code> attribute, and a <code>data</code> attribute that is list of numpy arrays - one for each frame in the experiment - or None if the layer was not present in that frame.</p> <p>The wrapper can be cast to a numpy array (with <code>BinaryLayers.asarray()</code> or <code>np.asarray(BinaryLayers)</code>) to stack all the layers into a single array.  The output array will have shape <code>(n_layers, *coord_shape, *frame_shape)</code>.</p>"},{"location":"API/nd2_binary/#nd2.BinaryLayers.asarray","title":"<code>asarray() -&gt; np.ndarray</code>","text":"<p>Stack all the layers/frames into a single array.</p> <p>The output array will have shape (n_layers, coord_shape, frame_shape).</p>"},{"location":"API/nd2_binary/#nd2.BinaryLayer","title":"<code>BinaryLayer</code>  <code>dataclass</code>","text":"<p>Wrapper for data from a single binary layer in an <code>nd2.ND2File</code>.</p> <p>A \"layer\" is a set of binary data that can be associated with a specific component in an ND2 file, such as a single channel.</p> <p>This object behaves like a <code>list[numpy.ndarray] | None</code>. It will have a length matching the number of frames in the file, with <code>None</code> for any frames that lack binary data.</p> <p>Attributes:</p> <ul> <li> <code>data</code>             (<code>list[ndarray] | None</code>)         \u2013          <p>The data for each frame. If a frame has no binary data, the value will be None.  Data will have the same length as the number of sequences in the file.</p> </li> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>The name of the binary layer.</p> </li> <li> <code>comp_name</code>             (<code>str</code>)         \u2013          <p>The name of the associated component, if Any.</p> </li> <li> <code>comp_order</code>             (<code>int</code>)         \u2013          <p>The order of the associated component, if Any.</p> </li> <li> <code>color</code>             (<code>int</code>)         \u2013          <p>The color of the binary layer.</p> </li> <li> <code>color_mode</code>             (<code>int</code>)         \u2013          <p>The color mode of the binary layer.  I believe this is related to how colors are chosen in NIS-Elements software.  Where \"0\" is direct color (i.e. use, the color value), \"8\" is color by 3D ... and I'm not sure about the rest :)</p> </li> <li> <code>state</code>             (<code>int</code>)         \u2013          <p>The state of the binary layer. (meaning still unclear)</p> </li> <li> <code>file_tag</code>             (<code>str</code>)         \u2013          <p>The key for the binary layer in the CustomData metadata, e.g. <code>RleZipBinarySequence_1_v1</code></p> </li> <li> <code>layer_id</code>             (<code>int</code>)         \u2013          <p>The ID of the binary layer.</p> </li> <li> <code>coordinate_shape</code>             (<code>tuple[int, ...]</code>)         \u2013          <p>The shape of the coordinates for the associated nd2 file.  This is used to reshape the data into a 3D array in <code>asarray</code>.</p> </li> </ul>"},{"location":"API/nd2_binary/#nd2.BinaryLayer.frame_shape","title":"<code>frame_shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Shape (Y, X) of each mask in <code>data</code>.</p>"},{"location":"API/nd2_binary/#nd2.BinaryLayer.asarray","title":"<code>asarray() -&gt; np.ndarray | None</code>","text":"<p>Stack all the frames into a single array.</p> <p>If there are no frames, returns None.</p>"},{"location":"API/structures/","title":"nd2.structures","text":""},{"location":"API/structures/#nd2.structures.ExpLoop","title":"<code>ExpLoop = Union[TimeLoop, NETimeLoop, XYPosLoop, ZStackLoop, CustomLoop]</code>  <code>module-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopParams","title":"<code>LoopParams = Union[TimeLoopParams, NETimeLoopParams, XYPosLoopParams, ZStackLoopParams]</code>  <code>module-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ModalityFlags","title":"<code>ModalityFlags = Literal['aux', 'brightfield', 'camera', 'diContrast', 'dsdConfocal', 'fluorescence', 'gaasp', 'iSIM', 'laserScanConfocal', 'liveSR', 'multiphoton', 'nonDescannedDetector', 'phaseContrast', 'pmt', 'RCM', 'remainder', 'SIM', 'sora', 'spectral', 'spinningDiskConfocal', 'sweptFieldConfocalPinhole', 'sweptFieldConfocalSlit', 'TIRF', 'transmitDetector', 'vaasIF', 'vaasNF', 'VCS', 'virtualFilter']</code>  <code>module-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam","title":"<code>AnimParam</code>  <code>dataclass</code>","text":"<p>Parameters of ROI position/shape.</p>"},{"location":"API/structures/#nd2.structures.AnimParam.boxShape","title":"<code>boxShape: BoxShape = field(default_factory=BoxShape)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam.center","title":"<code>center: XYZPoint</code>  <code>property</code>","text":"<p>Center point as a named tuple (x, y, z).</p>"},{"location":"API/structures/#nd2.structures.AnimParam.centerX","title":"<code>centerX: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam.centerY","title":"<code>centerY: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam.centerZ","title":"<code>centerZ: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam.enabled","title":"<code>enabled: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam.extrudedShape","title":"<code>extrudedShape: ExtrudedShape = field(default_factory=ExtrudedShape)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam.rotationZ","title":"<code>rotationZ: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.AnimParam.timeMs","title":"<code>timeMs: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes","title":"<code>Attributes</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.bitsPerComponentInMemory","title":"<code>bitsPerComponentInMemory: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.bitsPerComponentSignificant","title":"<code>bitsPerComponentSignificant: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.channelCount","title":"<code>channelCount: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.componentCount","title":"<code>componentCount: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.compressionLevel","title":"<code>compressionLevel: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.compressionType","title":"<code>compressionType: Literal['lossless', 'lossy', 'none'] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.heightPx","title":"<code>heightPx: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.pixelDataType","title":"<code>pixelDataType: Literal['float', 'unsigned']</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.sequenceCount","title":"<code>sequenceCount: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.tileHeightPx","title":"<code>tileHeightPx: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.tileWidthPx","title":"<code>tileWidthPx: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.widthBytes","title":"<code>widthBytes: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Attributes.widthPx","title":"<code>widthPx: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.BoxShape","title":"<code>BoxShape</code>","text":""},{"location":"API/structures/#nd2.structures.BoxShape.sizeX","title":"<code>sizeX: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.BoxShape.sizeY","title":"<code>sizeY: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.BoxShape.sizeZ","title":"<code>sizeZ: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Channel","title":"<code>Channel</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.Channel.channel","title":"<code>channel: ChannelMeta</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Channel.loops","title":"<code>loops: LoopIndices | None</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Channel.microscope","title":"<code>microscope: Microscope</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Channel.volume","title":"<code>volume: Volume</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ChannelMeta","title":"<code>ChannelMeta</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.ChannelMeta.colorRGB","title":"<code>colorRGB: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ChannelMeta.emissionLambdaNm","title":"<code>emissionLambdaNm: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ChannelMeta.excitationLambdaNm","title":"<code>excitationLambdaNm: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ChannelMeta.index","title":"<code>index: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ChannelMeta.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Contents","title":"<code>Contents</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.Contents.channelCount","title":"<code>channelCount: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Contents.frameCount","title":"<code>frameCount: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Coordinate","title":"<code>Coordinate</code>","text":""},{"location":"API/structures/#nd2.structures.Coordinate.index","title":"<code>index: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Coordinate.size","title":"<code>size: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Coordinate.type","title":"<code>type: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.CustomLoop","title":"<code>CustomLoop</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.CustomLoop.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.CustomLoop.nestingLevel","title":"<code>nestingLevel: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.CustomLoop.parameters","title":"<code>parameters: None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.CustomLoop.type","title":"<code>type: Literal['CustomLoop'] = 'CustomLoop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent","title":"<code>ExperimentEvent</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent.data","title":"<code>data: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent.id","title":"<code>id: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent.meaning","title":"<code>meaning: EventMeaning = EventMeaning.Unspecified</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent.stimulation","title":"<code>stimulation: StimulationEvent | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent.time","title":"<code>time: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExperimentEvent.time2","title":"<code>time2: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExtrudedShape","title":"<code>ExtrudedShape</code>","text":""},{"location":"API/structures/#nd2.structures.ExtrudedShape.basePoints","title":"<code>basePoints: list[XYPoint] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ExtrudedShape.sizeZ","title":"<code>sizeZ: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.FrameChannel","title":"<code>FrameChannel</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.FrameChannel.position","title":"<code>position: Position</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.FrameChannel.time","title":"<code>time: TimeStamp</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.FrameMetadata","title":"<code>FrameMetadata</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.FrameMetadata.channels","title":"<code>channels: list[FrameChannel]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.FrameMetadata.contents","title":"<code>contents: Contents</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ImageInfo","title":"<code>ImageInfo</code>","text":""},{"location":"API/structures/#nd2.structures.ImageInfo.bits_per_pixel","title":"<code>bits_per_pixel: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ImageInfo.components","title":"<code>components: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ImageInfo.height","title":"<code>height: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ImageInfo.width","title":"<code>width: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.InterpType","title":"<code>InterpType</code>","text":"<p>The role that the ROI plays.</p>"},{"location":"API/structures/#nd2.structures.InterpType.AnyROI","title":"<code>AnyROI = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.InterpType.BackgroundROI","title":"<code>BackgroundROI = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.InterpType.ReferenceROI","title":"<code>ReferenceROI = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.InterpType.StandardROI","title":"<code>StandardROI = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.InterpType.StimulationROI","title":"<code>StimulationROI = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopIndices","title":"<code>LoopIndices</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.LoopIndices.CustomLoop","title":"<code>CustomLoop: int | None = field(default=None, repr=False, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopIndices.NETimeLoop","title":"<code>NETimeLoop: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopIndices.TimeLoop","title":"<code>TimeLoop: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopIndices.XYPosLoop","title":"<code>XYPosLoop: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopIndices.ZStackLoop","title":"<code>ZStackLoop: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType","title":"<code>LoopType</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.CustomLoop","title":"<code>CustomLoop = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.ManTimeLoop","title":"<code>ManTimeLoop = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.NETimeLoop","title":"<code>NETimeLoop = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.PolarLoop","title":"<code>PolarLoop = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.SpectLoop","title":"<code>SpectLoop = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.TimeLoop","title":"<code>TimeLoop = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.Unknown","title":"<code>Unknown = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.XYDiscrLoop","title":"<code>XYDiscrLoop = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.XYPosLoop","title":"<code>XYPosLoop = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.ZStackLoop","title":"<code>ZStackLoop = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.LoopType.ZStackLoopAccurate","title":"<code>ZStackLoopAccurate = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Metadata","title":"<code>Metadata</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.Metadata.channels","title":"<code>channels: list[Channel] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Metadata.contents","title":"<code>contents: Contents | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope","title":"<code>Microscope</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.immersionRefractiveIndex","title":"<code>immersionRefractiveIndex: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.modalityFlags","title":"<code>modalityFlags: list[ModalityFlags] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.objectiveMagnification","title":"<code>objectiveMagnification: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.objectiveName","title":"<code>objectiveName: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.objectiveNumericalAperture","title":"<code>objectiveNumericalAperture: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.pinholeDiameterUm","title":"<code>pinholeDiameterUm: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.projectiveMagnification","title":"<code>projectiveMagnification: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Microscope.zoomMagnification","title":"<code>zoomMagnification: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.NETimeLoop","title":"<code>NETimeLoop</code>  <code>dataclass</code>","text":"<p>The time dimension of an nD experiment.</p>"},{"location":"API/structures/#nd2.structures.NETimeLoop.parameters","title":"<code>parameters: NETimeLoopParams</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.NETimeLoop.type","title":"<code>type: Literal['NETimeLoop'] = 'NETimeLoop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.NETimeLoopParams","title":"<code>NETimeLoopParams</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.NETimeLoopParams.periods","title":"<code>periods: list[Period]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Period","title":"<code>Period</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.Period.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.PeriodDiff","title":"<code>PeriodDiff</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.PeriodDiff.avg","title":"<code>avg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.PeriodDiff.max","title":"<code>max: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.PeriodDiff.min","title":"<code>min: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Position","title":"<code>Position</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.Position.name","title":"<code>name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Position.pfsOffset","title":"<code>pfsOffset: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Position.stagePositionUm","title":"<code>stagePositionUm: StagePosition</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ROI","title":"<code>ROI</code>  <code>dataclass</code>","text":"<p>ROI object from NIS Elements.</p>"},{"location":"API/structures/#nd2.structures.ROI.animParams","title":"<code>animParams: list[AnimParam] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ROI.guid","title":"<code>guid: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ROI.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ROI.info","title":"<code>info: RoiInfo</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo","title":"<code>RoiInfo</code>  <code>dataclass</code>","text":"<p>Info associated with an ROI.</p>"},{"location":"API/structures/#nd2.structures.RoiInfo.appData","title":"<code>appData: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.autodetected","title":"<code>autodetected: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.bpc","title":"<code>bpc: int = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.color","title":"<code>color: int = 255</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.compCount","title":"<code>compCount: int = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.cookie","title":"<code>cookie: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.gradientStimulation","title":"<code>gradientStimulation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.gradientStimulationBitDepth","title":"<code>gradientStimulationBitDepth: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.gradientStimulationHi","title":"<code>gradientStimulationHi: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.gradientStimulationLo","title":"<code>gradientStimulationLo: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.interpType","title":"<code>interpType: InterpType</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.label","title":"<code>label: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.locked","title":"<code>locked: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.multiFrame","title":"<code>multiFrame: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.scope","title":"<code>scope: ScopeType = ScopeType.Global</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.shapeType","title":"<code>shapeType: RoiShapeType</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiInfo.stimulationGroup","title":"<code>stimulationGroup: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType","title":"<code>RoiShapeType</code>","text":"<p>The type of ROI shape.</p>"},{"location":"API/structures/#nd2.structures.RoiShapeType.Any","title":"<code>Any = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Bezier","title":"<code>Bezier = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Circle","title":"<code>Circle = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Ellipse","title":"<code>Ellipse = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Line","title":"<code>Line = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Point","title":"<code>Point = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.PolyLine","title":"<code>PolyLine = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Polygon","title":"<code>Polygon = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Raster","title":"<code>Raster = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Rectangle","title":"<code>Rectangle = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Ring","title":"<code>Ring = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Spiral","title":"<code>Spiral = 12</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.RoiShapeType.Square","title":"<code>Square = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ScopeType","title":"<code>ScopeType</code>","text":""},{"location":"API/structures/#nd2.structures.ScopeType.Any","title":"<code>Any = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ScopeType.Global","title":"<code>Global = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ScopeType.MPoint","title":"<code>MPoint = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.SpectLoop","title":"<code>SpectLoop</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.SpectLoop.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.SpectLoop.type","title":"<code>type: Literal['SpectLoop'] = 'SpectLoop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.StagePosition","title":"<code>StagePosition</code>","text":""},{"location":"API/structures/#nd2.structures.StagePosition.x","title":"<code>x: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.StagePosition.y","title":"<code>y: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.StagePosition.z","title":"<code>z: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.StimulationEvent","title":"<code>StimulationEvent</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.StimulationEvent.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.StimulationEvent.loop_index","title":"<code>loop_index: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.StimulationEvent.position","title":"<code>position: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.StimulationEvent.type","title":"<code>type: StimulationType = StimulationType.NoStimulation</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.T","title":"<code>T</code>","text":""},{"location":"API/structures/#nd2.structures.T.AnimParams_Size","title":"<code>AnimParams_Size: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.T.GUID","title":"<code>GUID: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.T.Id","title":"<code>Id: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.T.Info","title":"<code>Info: dict</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo","title":"<code>TextInfo</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.appVersion","title":"<code>appVersion: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.author","title":"<code>author: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.capturing","title":"<code>capturing: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.conclusion","title":"<code>conclusion: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.date","title":"<code>date: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.group","title":"<code>group: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.imageId","title":"<code>imageId: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.info1","title":"<code>info1: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.info2","title":"<code>info2: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.location","title":"<code>location: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.optics","title":"<code>optics: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.sampleId","title":"<code>sampleId: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.sampling","title":"<code>sampling: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TextInfo.type","title":"<code>type: str</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeLoop","title":"<code>TimeLoop</code>  <code>dataclass</code>","text":"<p>The time dimension of an experiment.</p>"},{"location":"API/structures/#nd2.structures.TimeLoop.parameters","title":"<code>parameters: TimeLoopParams</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeLoop.type","title":"<code>type: Literal['TimeLoop'] = 'TimeLoop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeLoopParams","title":"<code>TimeLoopParams</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.TimeLoopParams.durationMs","title":"<code>durationMs: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeLoopParams.periodDiff","title":"<code>periodDiff: PeriodDiff</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeLoopParams.periodMs","title":"<code>periodMs: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeLoopParams.startMs","title":"<code>startMs: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeStamp","title":"<code>TimeStamp</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.TimeStamp.absoluteJulianDayNumber","title":"<code>absoluteJulianDayNumber: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.TimeStamp.relativeTimeMs","title":"<code>relativeTimeMs: float</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume","title":"<code>Volume</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.axesCalibrated","title":"<code>axesCalibrated: tuple[bool, bool, bool]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.axesCalibration","title":"<code>axesCalibration: tuple[float, float, float]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.axesInterpretation","title":"<code>axesInterpretation: tuple[AxisInterpretation, AxisInterpretation, AxisInterpretation]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.bitsPerComponentInMemory","title":"<code>bitsPerComponentInMemory: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.bitsPerComponentSignificant","title":"<code>bitsPerComponentSignificant: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.cameraTransformationMatrix","title":"<code>cameraTransformationMatrix: tuple[float, float, float, float]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.componentCount","title":"<code>componentCount: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.componentDataType","title":"<code>componentDataType: Literal['unsigned', 'float']</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.componentMaxima","title":"<code>componentMaxima: list[float] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.componentMinima","title":"<code>componentMinima: list[float] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.pixelToStageTransformationMatrix","title":"<code>pixelToStageTransformationMatrix: tuple[float, float, float, float, float, float] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.Volume.voxelCount","title":"<code>voxelCount: tuple[int, int, int]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYPoint","title":"<code>XYPoint</code>","text":""},{"location":"API/structures/#nd2.structures.XYPoint.x","title":"<code>x: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYPoint.y","title":"<code>y: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYPosLoop","title":"<code>XYPosLoop</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.XYPosLoop.parameters","title":"<code>parameters: XYPosLoopParams</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYPosLoop.type","title":"<code>type: Literal['XYPosLoop'] = 'XYPosLoop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYPosLoopParams","title":"<code>XYPosLoopParams</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.XYPosLoopParams.isSettingZ","title":"<code>isSettingZ: bool</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYPosLoopParams.points","title":"<code>points: list[Position]</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYZPoint","title":"<code>XYZPoint</code>","text":""},{"location":"API/structures/#nd2.structures.XYZPoint.x","title":"<code>x: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYZPoint.y","title":"<code>y: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.XYZPoint.z","title":"<code>z: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoop","title":"<code>ZStackLoop</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoop.parameters","title":"<code>parameters: ZStackLoopParams</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoop.type","title":"<code>type: Literal['ZStackLoop'] = 'ZStackLoop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoopParams","title":"<code>ZStackLoopParams</code>  <code>dataclass</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoopParams.bottomToTop","title":"<code>bottomToTop: bool</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoopParams.deviceName","title":"<code>deviceName: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoopParams.homeIndex","title":"<code>homeIndex: int</code>  <code>instance-attribute</code>","text":""},{"location":"API/structures/#nd2.structures.ZStackLoopParams.stepUm","title":"<code>stepUm: float</code>  <code>instance-attribute</code>","text":""}]}